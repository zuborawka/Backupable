<?php

/**
 * Backup utility behavior based on table name and fields.
 */
class BackuppableBehavior extends ModelBehavior
{

	public $settings = array();
	public $mapMethods = array();

/**
 * The model behaves backuppable must have these properties.
 * @var array
 */
	protected $_requireProperties = array(
		'backupFields',
	);

/**
 * The model could hold these properties for the behavior.
 * The key is property name, the value is default value.
 * @var array
 */
	protected $_optionProperties = array(
		'autoBackup' => true,
		'skipSame' => false,
	);

/**
 * Backup Model object generated by magic method __get
 * @var Model
 */
	// public $Backup;

	public function __get($name) {
		if ($name === 'Backup') {
			$this->Backup = ClassRegistry::init('Backuppable.Backup');
			return $this->Backup;
		}
	}

	public function setup(Model $model, $config = array()) {

		foreach ($this->_requireProperties as $prop) {
			if (!isset($config[$prop])) {
				if (!isset($model->backup[$prop])) {
					throw new InvalidArgumentException(__('"' . $prop . '" of ' . $model->alias . '\'s property was missing.'));
				}
				$config[$prop] = $model->backup[$prop];
			}
		}

		$config['backupFields'] = (array)$config['backupFields'];

		foreach ($this->_optionProperties as $prop => $default) {
			if (!isset($config[$prop]) && isset($model->backup[$prop])) {
				$config[$prop] = $model->backup[$prop];
			} else {
				$config[$prop] = $default;
			}
		}

		$this->settings[$model->alias] = $config;
	}

/*
	public function cleanup(Model $model) {
		if (isset($this->settings[$model->alias])) {
			unset($this->settings[$model->alias]);
		}
	}
*/

	public function beforeFind(Model $model, $query) {
		return true;
	}

	public function afterFind(Model $model, $results, $primary) {
	}

	public function beforeValidate(Model $model) {
		return true;
	}

	public function afterValidate(Model $model) {
		return true;
	}

	public function beforeSave(Model $model) {
		return true;
	}

	public function afterSave(Model $model, $created) {
		if ($this->settings[$model->alias]['autoBackup']) {
			$this->backup($model);
		}
		return true;
	}

	public function beforeDelete(Model $model, $cascade = true) {
		return true;
	}

	public function afterDelete(Model $model) {
	}

	public function onError(Model $model, $error) {
	}

/*
	protected function _addToWhitelist(Model $model, $field) {
		if (is_array($field)) {
			foreach ($field as $f) {
				$this->_addToWhitelist($model, $f);
			}
			return;
		}
		if (!empty($model->whitelist) && !in_array($field, $model->whitelist)) {
			$model->whitelist[] = $field;
		}
	}
*/

/**
 * backup the record
 *
 * @param Model
 * @param array
 * @return array|false Created data. If it could not get ID, it returns false.
 */
	public function backup(Model $model, $options = array()) {

		list($id, $table) = $this->_getSrcIdAndTableName($model, $options);
		if (! $model->exists($id)) {
			return array();
		}

		$settings = $this->settings[$model->alias];

		$fields = $settings['backupFields'];
		$conditions = array($model->alias . '.' . $model->primaryKey => $id);
		$model->recursive = -1;
		$data = $model->find('first', compact('fields', 'conditions'));

		$serialized = serialize($data[$model->alias]);

		$backupData = array(
			'Backup' => array(
				'id' => null,
				'table_name' => $table,
				'src_id' => $id,
				'data' => $serialized,
			),
		);

		if ($settings['skipSame']) {
			$last = serialize($this->rememberLast($model, $options));
			if ($last === $serialized) {
				return false;
			}
		}

		$this->Backup->create();
		$res = $this->Backup->save($backupData);
		return $res;
	}

/**
 * Get the history of record.
 * It returns a list of Backup's id and created time from latest to earliest by default.
 * Options:
 *    limit, page, order, fields
 * @param Model
 * @param array
 * @return array
 */
	public function history(Model $model, $options = array()) {
		// default options are
		$limit = 20;
		$page = 1;
		$order = 'Backup.id DESC';
		$fields = array('id', 'created');

		if (is_array($options)) {
			extract($options);
		}

		list($id, $table) = $this->_getSrcIdAndTableName($model, $options);
		$conditions = array(
			'Backup.table_name' => $table,
			'Backup.src_id' => $id,
		);
		$recursive = -1;
		$history = $this->Backup->find('all', compact('conditions', 'fields', 'order', 'limit', 'page', 'recursive'));
		return $history;
	}

/**
 * Get backup data.
 * If the table name, source id and backup id are not matched, it returns false.
 * Options:
 *   'backupId' -- required
 *   'id' -------- option (if it is empty, the method searches $model->id)
 *
 * @param Model
 * @param array
 */
	public function remember(Model $model, $options = array()) {
		if (isset($options['backupId'])) {
			$backupId = $options['backupId'];
		} else {
			return false;
		}
		list($id, $table) = $this->_getSrcIdAndTableName($model, $options);
		$conditions = array(
			'Backup.id' => $backupId,
			'Backup.table_name' => $table,
			'Backup.src_id' => $id,
		);
		$fields = array('data');
		$data = $this->Backup->find('first', compact('conditions', 'fields'));
		if (empty($data)) {
			return array();
		}
		$remember = unserialize($data['Backup']['data']);
		$remember[$model->primaryKey] = $id;
		return $remember;
	}

/**
 * Get the last backup data
 *
 * @param Model
 * @param array
 * @return array
 */
	public function rememberLast(Model $model, $options = array()) {
		list($id, $table) = $this->_getSrcIdAndTableName($model, $options);
		$conditions = array(
			'Backup.table_name' => $table,
			'Backup.src_id' => $id,
		);
		$order = 'Backup.id DESC';
		$lastBackup = $this->Backup->find('first', compact('conditions', 'order'));
		if (empty($lastBackup['Backup']['data'])) {
			return array();
		}
		return unserialize($lastBackup['Backup']['data']);
	}

/**
 * Restore the record by backup data.
 * If the table name, source id and backup id are not matched, it returns false.
 * Options:
 *   'backupId' -- required
 *   'id' -------- option (if it is empty, the method searches $model->id)
 *
 * @param Model
 * @param array
 */
	public function restore(Model $model, $options = array()) {
		$restore = $this->remember($model, $options);
		if (empty($restore)) {
			return false;
		}
		$model->id = $restore[$model->primaryKey];
		return $model->save(array($model->alias => $restore));
	}

	protected function _getSrcId(Model $model, $options = array()) {
		if (is_int($options)) {
			$id = $options;
		} elseif (isset($options['id'])) {
			$id = $options['id'];
		} elseif (isset($model->id)) {
			$id = $model->id;
		} else {
			$id = null;
		}
		return $id;
	}

	protected function _getTableName($model) {
		if ($model->tablePrefix) {
			$table = $model->tablePrefix . $model->useTable;
		} else {
			$table = ConnectionManager::$config->{$model->useDbConfig}['prefix'] . $model->useTable;
		}
		return $table;
	}

	protected function _getSrcIdAndTableName(Model $model, $options = array()) {
		return array($this->_getSrcId($model, $options), $this->_getTableName($model));
	}

}